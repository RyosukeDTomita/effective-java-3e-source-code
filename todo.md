# 解説を記載した項目にチェックをつける

## 第２章 オブジェクトの生成と破棄

- [ ] 項目１ コンストラクタの代わりにstaticファクトリメソッドを検討する
- [ ] 項目２ 多くのコンストラクタパラメータに直面したときにはビルダーを検討する
- [ ] 項目３ privateのコンストラクタかenum型でシングルトン特性を強制する
- [ ] 項目４ privateのコンストラクタでインスタンス化不可能を強制する
- [ ] 項目５ 資源を直接結び付けるよりも依存性注入を選ぶ
- [ ] 項目６ 不必要なオブジェクトの生成を避ける
- [ ] 項目７ 使われなくなったオブジェクト参照を取り除く
- [ ] 項目８ ファイナライザとクリーナーを避ける
- [ ] 項目９ try-よりもtry-with-resourcesを選ぶ

## 第３章 すべてのオブジェクトに共通のメソッド

- [ ] 項目10 equalsをオーバーライドするときは一般契約に従う
- [ ] 項目11 equalsをオーバーライドするときは、常にhashCodeをオーバーライドする
- [ ] 項目12 toStringを常にオーバーライドする
- [ ] 項目13 cloneを注意してオーバーライドする
- [ ] 項目14 Comparableの実装を検討する

## 第４章 クラスとインタフェース

- [ ] 項目15 クラスとメンバーへのアクセス可能性を最小限にする
- [ ] 項目16 publicのクラスでは、publicのフィールドではなく、アクセッサ―メソッドを使う
- [ ] 項目17 可変性を最小限にする
- [x] 項目18 継承よりもコンポジションを選ぶ
- [ ] 項目19 継承のために設計および文書化する、でなければ継承を禁止する
- [ ] 項目20 抽象クラスよりもインタフェースを選ぶ
- [ ] 項目21 将来のためにインタフェースを設計する
- [ ] 項目22 型を定義するためだけにインタフェースを使う
- [ ] 項目23 タグ付きクラスよりもクラス階層を選ぶ
- [ ] 項目24 非staticのメンバークラスよりもstaticのクラスに限定する
- [ ] 項目25 ソースファイルを単一のトップレベルのクラスに限定する

## 第５章 ジェネリックス

- [ ] 項目26 原形を使わない
- [ ] 項目27 無検査警告を取り除く
- [ ] 項目28 配列よりもリストを選ぶ
- [ ] 項目29 ジェネリック型を使う
- [ ] 項目30 ジェネリックメソッドを使う
- [ ] 項目31 ＡＰＩの柔軟性向上のために境界ワイルドカードを使う
- [ ] 項目32 ジェネリックスと可変長引数を注意して組み合わせる
- [ ] 項目33 型安全な異種コンテナを検討する

## 第６章 enumとアノテーション

- [ ] 項目34 int定数の代わりにenumを使う
- [ ] 項目35 序数の代わりにインスタンスフィールドを使う
- [ ] 項目36 ビットフィールドの代わりにEnumSetを使う
- [ ] 項目37 序数インデックスの代わりにEnumMapを使う
- [ ] 項目38 拡張可能なenumをインタフェースで模倣する
- [ ] 項目39 命名パターンよりもアノテーション選ぶ
- [ ] 項目40 常にOverrideアノテーションを使う
- [ ] 項目41 型を定義するためにマーカーインタフェースを使う

## 第７章 ラムダとストリーム

- [ ] 項目42 無名クラスよりもラムダを選ぶ
- [ ] 項目43 ラムダよりもメソッド参照を選ぶ
- [ ] 項目44 標準の関数型インタフェースを使う
- [ ] 項目45 ストリームを注意して使う
- [ ] 項目46 ストリームで副作用のない関数を選ぶ
- [ ] 項目47 戻り値型としてStreamよりもCollectionを選ぶ
- [ ] 項目48 ストリームを並列化するときは注意を払う

## 第８章 メソッド

- [ ] 項目49 パラメータの正当性を検査する
- [ ] 項目50 必要な場合、防御的にコピーする
- [ ] 項目51 メソッドのシグニチャを注意深く設計する
- [ ] 項目52 オーバーロードを注意して使う
- [ ] 項目53 可変長引数を注意して使う
- [ ] 項目54 nullではなく、空コレクションか空配列を返す
- [ ] 項目55 オプショナルを注意して返す
- [ ] 項目56 すべて公開のＡＰＩ要素に対してドキュメントコメントを書く

## 第９章 プログラミング一般

- [ ] 項目57 ローカル変数のスコープを最小限にする
- [ ] 項目58 従来のforループよりもfor―eachループを選ぶ
- [ ] 項目59 ライブラリを知り、ライブラリを使う
- [ ] 項目60 正確な答えが必要ならば、floatとdoubleを避ける
- [ ] 項目61 ボクシングされた基本データよりも基本データ型を選ぶ
- [ ] 項目62 他の型が適切な場所では、文字列を避ける
- [ ] 項目63 文字列結合のパフォーマンスに用心する
- [ ] 項目64 インタフェースでオブジェクトを参照する
- [ ] 項目65 リフレクションよりもインタフェースを選ぶ
- [ ] 項目66 ネイティブメソッドを注意して使う
- [ ] 項目67 注意して最適化する
- [ ] 項目68 一般的に受け入れられている命名規約を守る

## 第10章 例外

- [ ] 項目69 例外的状態にだけ例外を使う
- [ ] 項目70 回復可能な状態にはチェックされる例外を、プログラミングエラーには実行時例外を使う
- [ ] 項目71 チェックされる例外を不必要に使うのを避ける
- [ ] 項目72 標準的な例外を使う
- [ ] 項目73 抽象概念に適した例外をスローする
- [ ] 項目74 各メソッドがスローするすべての例外を文書化する
- [ ] 項目75 詳細メッセージにエラー記録情報を含める
- [ ] 項目76 エラーアトミック性に努める
- [ ] 項目77 例外を無視しない

## 第11章 並行性

- [ ] 項目78 共有された可変データへのアクセスを同期する
- [ ] 項目79 過剰な同期は避ける
- [ ] 項目80 スレッドよりもエグゼキュータ、タスク、ストリームを選ぶ
- [ ] 項目81 waitとnotifyよりも並行処理ユーティリティを選ぶ
- [ ] 項目82 スレッド安全性を文書化する
- [ ] 項目83 遅延初期化を注意して使う
- [ ] 項目84 スレッドスケジューラに依存しない

## 第12章 シリアライズ

- [ ] 項目85 Javaのシリアライズよりも代替手段を選ぶ
- [ ] 項目86 Serializableを細心の注意を払って実装する
- [ ] 項目87 カスタムシリアライズ形式の使用を検討する
- [ ] 項目88 防御的にreadObjectメソッドを書く
- [ ] 項目89 インスタンス制御に対しては、readResolveよりもenum型を選ぶ
- [ ] 項目90 シリアライズされたインスタンスの代わりに、シリアライズ・プロキシを検討する
